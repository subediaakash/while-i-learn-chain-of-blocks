- Data origin authentication
- Non Repudiation  : a service that offers definitive proof that a particular activity has occurred .

-Accountability : assurance which states that actions affecting security can be traced back to the responsible party.

Cryptographic Primitives : Keyless Primitives , Symmetric Primitives , Assymetric Primitives

 	- Keyless : Random Numbers ,Hash Funcs
	- Symmetric Primitives : Secret key ciphers , Macs
	- Asymmetric Primitives : Digital Signatures , Public Key ciphers

Symmetric Cryptography : same key is used to encrypt and decrypt data .Ex: DES, AES (block ciphers)
	Stream Ciphers : encryption algos applied on a bit by bit basis. They are  simple moduloe  2 additions / XOR operations 
		Types : Syncronous and Async
		Syncronous : Dependent only on the key
		Asyncronous : depended on key and encrypted data
	Block Ciphers : Breaks up the texts into blocks of fixed size and then perform encryption
		Cipher block chaining : each block of plain text is XOR'd with the previously encrypted block.

	Cryptographic hash node : block ciphers are used as a compression function  to produce a hash of a plain text 
------------------------------------------------------------------------------------------------


Advanced encryption standard : 
	Subbypte place : eg a-> p, b->z ...
	Shift Rows 
	Mix colms
	Add Round Key

-----------------------------------------------------------------------------------------------

Public Key Cryptography 
	Public keys and private keys are  used for encyprtion and decryption here 
	RSA :
	1 : modulus generation : select two large prime numbers p and q , multiply p and q , we get n = p.q to generate modulus n
        2 : Generate Co prime
		Assume a number called e 
		e should be a number that no nuumber other than one can divide e and (p-1).(q-1)
		this is called co-prime , that is e is the co prime of(p-1)(q-1), in simpler terms gcd(e, (p-1)(q-1)) = 1.
	3 : Generate the public key  :
		the modulus generated in step one and co prime e generated in step 2 is a pair together that is public key. This part is the public part that can be shared with anyone.
	4 : Generate the private key :
		The private key d here is calculated from p q and e. The private key is basically the inverse of e modulo(p-1)(q-1). in the equation form it is:
		e x d = 1 mod(p-1)(q-1)

		we calculate d . the d is the private key

Encryption and Decryption using RSA
	C = p^e mod n
	this means plain text p is raised e number of times and then reduced to modulo n. 
Decrytion in Rsa is provided in the following equation 
	P = C^d mod n
	this means the receiver who has a public key pair(n,e) can decipher the data by raising c to value the private key d and reducing to modulo n.

Elliptic Curve Cryptography :
	Elliptic curve crytography is based on discrete logarithm problem founded upon elliptic curves over finite fields (A field is like a ring, but better:
    Every nonzero element has a multiplicative inverse (you can divide by it).
    Multiplication is commutative.)

ECC is generally used for : 
	Key exchange
	Digital Signatures

Maths behind ECC
	elliptic curve is basically a type of polynomial equation weierstrass equation , which generates a curve over a finite field .
       elliptic cover is defined as :  y^2 = x^3+Ax+B mod P


--------------------------------------------------------------------------------------------------------------

RSA public and Private Key Pair 

Private key using openssl:
	openssl genpkey -algorithm RSA -out privatekey.pem -pkeyopt \
rsa_keygen_bits:1024
public key gen : 
	openssl rsa -pubout -in privatekey.pem -out publickey.pem
	
public key and private key are base 64 encoded
--------------------------------------------------------------------------------------------------------------

Hash functions : 
    It’s a special function that:
    Takes any input (a word, file, image, number…)
    Crunches it through some fixed recipe
    Produces a short, fixed-size output (called a hash or digest)
   eg : SHA 3 , RIPEMD,WHIRLPOOL


	Message Authenticated Codes (MACs)
	MACs are sometimes called keyed hash functions, and they can be used to provide message integrity and
authentication. More specifically, they are used to provide data origin authentication.
	
	Here : 
	Sender computes 
	MAC = HMAC_SHA256("Pay Bob 100", "k1ngf1sh")
MAC = "6a3f…b9"

	Sends : 
	Message: Pay Bob 100
	MAC:     6a3f…b9

	Receiver :
	Uses "k1ngf1sh" and "Pay Bob 100" to recompute.
	If it gets "6a3f…b9" → all good.
	If not → someone messed with it or used the wrong key.

A plain hash (like SHA-256) protects against accidental changes,
but anyone can compute a hash if they know the message.

MACs add a secret key, so only people with the key can make a valid code.
This protects against intentional tampering.

--------------------------------------------------------------------------------------------------------------

Hash Tables : 
A hash table is a data structure that is used to map keys to values. Internally, a hash function is used to calculate an index into an array of buckets from which the required value can be found.

 	Distributed Hash Tables :
	Data is passed through a hash function, which then generates
a compact key. This key is then linked with the data (values) on the peer-to-peer network. When users on the
network request the data (via the filename), the filename can be hashed again to produce the same key, and any
node on the network can then be requested to find the corresponding data. DHT provides decentralization, fault
tolerance, and scalability:

Digital Signatures : 
	Digital signatures are used in blockchain where the transactions are digitally signed by senders using their private key before broadcasting the transaction to the network. This digital signing, proves they are the rightful owner of the asset, for example, bitcoins

RSA digital signature algorithm 
	Following is the RSA digital signature algorithm : 
	- Calculate the hash value of the data packet 
	- Sign the hash value with the signer's private key

