- Data origin authentication
- Non Repudiation  : a service that offers definitive proof that a particular activity has occurred .

-Accountability : assurance which states that actions affecting security can be traced back to the responsible party.

Cryptographic Primitives : Keyless Primitives , Symmetric Primitives , Assymetric Primitives

 	- Keyless : Random Numbers ,Hash Funcs
	- Symmetric Primitives : Secret key ciphers , Macs
	- Asymmetric Primitives : Digital Signatures , Public Key ciphers

Symmetric Cryptography : same key is used to encrypt and decrypt data .Ex: DES, AES (block ciphers)
	Stream Ciphers : encryption algos applied on a bit by bit basis. They are  simple moduloe  2 additions / XOR operations 
		Types : Syncronous and Async
		Syncronous : Dependent only on the key
		Asyncronous : depended on key and encrypted data
	Block Ciphers : Breaks up the texts into blocks of fixed size and then perform encryption
		Cipher block chaining : each block of plain text is XOR'd with the previously encrypted block.

	Cryptographic hash node : block ciphers are used as a compression function  to produce a hash of a plain text 
------------------------------------------------------------------------------------------------


Advanced encryption standard : 
	Subbypte place : eg a-> p, b->z ...
	Shift Rows 
	Mix colms
	Add Round Key

-----------------------------------------------------------------------------------------------

Public Key Cryptography 
	Public keys and private keys are  used for encyprtion and decryption here 
	RSA :
	1 : modulus generation : select two large prime numbers p and q , multiply p and q , we get n = p.q to generate modulus n
        2 : Generate Co prime
		Assume a number called e 
		e should be a number that no nuumber other than one can divide e and (p-1).(q-1)
		this is called co-prime , that is e is the co prime of(p-1)(q-1), in simpler terms gcd(e, (p-1)(q-1)) = 1.
	3 : Generate the public key  :
		the modulus generated in step one and co prime e generated in step 2 is a pair together that is public key. This part is the public part that can be shared with anyone.
	4 : Generate the private key :
		The private key d here is calculated from p q and e. The private key is basically the inverse of e modulo(p-1)(q-1). in the equation form it is:
		e x d = 1 mod(p-1)(q-1)

		we calculate d . the d is the private key

Encryption and Decryption using RSA
	C = p^e mod n
	this means plain text p is raised e number of times and then reduced to modulo n. 
Decrytion in Rsa is provided in the following equation 
	P = C^d mod n
	this means the receiver who has a public key pair(n,e) can decipher the data by raising c to value the private key d and reducing to modulo n.

Elliptic Curve Cryptography :
	Elliptic curve crytography is based on discrete logarithm problem founded upon elliptic curves over finite fields (A field is like a ring, but better:
    Every nonzero element has a multiplicative inverse (you can divide by it).
    Multiplication is commutative.)

ECC is generally used for : 
	Key exchange
	Digital Signatures

Maths behind ECC
	elliptic curve is basically a type of polynomial equation weierstrass equation , which generates a curve over a finite field .
       elliptic cover is defined as :  y^2 = x^3+Ax+B mod P


--------------------------------------------------------------------------------------------------------------

RSA public and Private Key Pair 

Private key using openssl:
	openssl genpkey -algorithm RSA -out privatekey.pem -pkeyopt \
rsa_keygen_bits:1024

public key gen : 
	openssl rsa -pubout -in privatekey.pem -out publickey.pem
	
public key and private key are base 64 encoded
--------------------------------------------------------------------------------------------------------------

Hash functions : 
    It’s a special function that:
    Takes any input (a word, file, image, number…)
    Crunches it through some fixed recipe
    Produces a short, fixed-size output (called a hash or digest)
   eg : SHA 3 , RIPEMD,WHIRLPOOL


	Message Authenticated Codes (MACs)
	MACs are sometimes called keyed hash functions, and they can be used to provide message integrity and
authentication. More specifically, they are used to provide data origin authentication.
	
	Here : 
	Sender computes 
	MAC = HMAC_SHA256("Pay Bob 100", "k1ngf1sh")
MAC = "6a3f…b9"

	Sends : 
	Message: Pay Bob 100
	MAC:     6a3f…b9

	Receiver :
	Uses "k1ngf1sh" and "Pay Bob 100" to recompute.
	If it gets "6a3f…b9" → all good.
	If not → someone messed with it or used the wrong key.

A plain hash (like SHA-256) protects against accidental changes,
but anyone can compute a hash if they know the message.

MACs add a secret key, so only people with the key can make a valid code.
This protects against intentional tampering.

--------------------------------------------------------------------------------------------------------------

